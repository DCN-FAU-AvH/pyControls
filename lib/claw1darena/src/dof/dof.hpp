/*
  This file is part of claw1dArena, a software library to discretize
  one-dimensional conservation laws.

  Copyright (C) 2017 Matteo Semplice

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

  For details on the licence, see the COPYING file at the root of the tree.
*/

/** @defgroup dof Tools for representing the degrees of freedom
 *
 * @{
 */

/*! \file dof.hpp
 *  \brief Declaration of DoF<M>
 */

#ifndef __DOF
#define __DOF

#include "../config.h"
#include <iostream>
//#include <initializer_list>
#include <array>
#include <cmath>

/*! \brief A class to represent Degrees of Freedom
 *
 * A std::array with overloaded mathematical operations
 */

template <int N, class T>
class DoF{
private:
  //! Inner storage of data
  std::array<T,N> _data;
public:
  //! Number of elements
  enum {numElements = N};
  //Dune::FieldVector ha il commento:
  // Using C++11 unified initialization tends to generate fastest code
  //quindi lo facciamo anche noi, ma andrebbe testato
  //! Default constructor
  DoF() : _data{} {}
  //requires std=c++11
/*
    DoF(std::initializer_list<T> const & l) {//copiato da FieldVector in Dune 2.4
    std::copy_n(l.begin(),
          std::min(static_cast<std::size_t>(N),l.size()),
          _data.begin());
    } //requires std=c++11
    */
  //! Copy constructor
  explicit DoF(T d) : _data{} {for (uint i=0; i<N; i++) _data[i]=d;}
  //Autogenerated copy constructor works fine
  //Autogenerated assignment constructor works fine

  // tinyvec2.hh lo definisce come
  //T_numtype& restrict operator[](unsigned i)
  // cosa vuol dire restrict??
  //! Access to a component
  T & operator[] (unsigned i) {return _data[i];}
  //! Read-only access to a component
  const T & operator[] (unsigned i) const {return _data[i];}

  //! Raw access to data: use with care!
  T* data() noexcept {return _data.data();}

  //! Add a constant value to all components
  DoF& operator +=(T d){for (uint i=0; i<N; i++) _data[i]+=d; return *this;}
  //! Subtract a constant value to all components
  DoF& operator -=(T d){for (uint i=0; i<N; i++) _data[i]-=d; return *this;}
  //! Multiply all components by a scalar value
  DoF& operator *=(T d){for (uint i=0; i<N; i++) _data[i]*=d; return *this;}
  //! Divide all components by a scalar value
  DoF& operator /=(T d){for (uint i=0; i<N; i++) _data[i]/=d; return *this;}
  //! Component-wise division
  DoF& operator /=(DoF& u){for (uint i=0; i<N; i++) _data[i]/=u._data[i]; return *this;}

  //! Component-wise sum
  DoF& operator +=(const DoF& d){for (uint i=0; i<N; i++) _data[i]+=d._data[i]; return *this;}
  //! Component-wise subtraction
  DoF& operator -=(const DoF& d){for (uint i=0; i<N; i++) _data[i]-=d._data[i]; return *this;}

  //! Infinity norm
  T infinity_norm(){
    T n=0;
    for (uint i=0; i<N; i++){
      T x= std::abs(_data[i]);
      if (n < x)
        n=x;
    }
    return n;
  }

  //! -DoF (component-wise)
  template<int M, class R>
    friend DoF<M,R> operator-(const DoF<M,R>&);
  //! DoF + scalar (component-wise)
  template<int M, class R>
    friend DoF<M,R> operator+(const DoF<M,R>&, const R&);
  //! scalar * DoF (component-wise)
  template<int M, class R>
    friend DoF<M,R> operator*(const R&, const DoF<M,R>&);
  //! DoF / scalar (componentwise)
  template<int M, class R>
    friend DoF<M,R> operator/(const DoF<M,R>&, const R&);
  //! scalar / DoF (componentwise)
  template<int M, class R>
    friend DoF<M,R> operator/(const R& , const DoF<M,R>&);
  //! DoF - DoF  (component-wise)
  template<int M, class R>
    friend DoF<M,R> operator-(const DoF<M,R>&, const DoF<M,R>&);
  //! DoF + DoF (component-wise)
  template<int M, class R>
    friend DoF<M,R> operator+(const DoF<M,R>&, const DoF<M,R>&);
  //! max(DoF , DoF), component-wise
  template<int M, class R>
    friend DoF<M,R> eWiseMax(const DoF<M,R>&, const DoF<M,R>&);
  //! abs(DoF), component-wise
  template<int M, class R>
    friend DoF<M,R> eWiseAbs(const DoF<M,R>&);
  //! DoF .* DoF (component-wise)
  template<int M, class R>
    friend DoF<M,R> eWiseProduct(const DoF<M,R>&, const DoF<M,R>&);
  //! DoF ./ DoF (component-wise)
  template<int M, class R>
    friend DoF<M,R> eWiseDivide(const DoF<M,R>&, const DoF<M,R>&);
  //! DoF^2  (component-wise)
  template<int M, class R>
    friend DoF<M,R> eWiseSquare(const DoF<M,R>&);
  //! DoF^exp  (component-wise)
  template<int M, class R>
    friend DoF<M,R> eWisePow(const DoF<M,R>&, const tD&);
  //! Output to a stream
  template<int M, class R>
    friend std::ostream& operator<<(std::ostream&, const DoF<M,R>);
  template<int M, class R>
    friend std::istream& operator>>(std::istream& , DoF<M,R>);

};

#endif

/** @} */
